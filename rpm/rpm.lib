//############### rpm.lib ######################################################
// RPM (Recursive Phase Modulation) Oscillator Library
//
// Based on Norio Tomisawa's 1981 Yamaha patent for feedback FM synthesis:
// "Tone production method for an electronic musical instrument" (US4249447A)
//
// Uses a "hunting filter" (2-point moving average) in the feedback path
// to suppress Nyquist-rate limit cycle oscillations at high modulation indices.
//
// #### Usage
//
// ```
// dfl = library("rpm.lib");
// process = dfl.rpm.saw(freq, beta);
// ```
//
// #### Reference
//
// * <https://patents.google.com/patent/US4249447>
//##############################################################################

declare name "RPM Library";
declare author "David Lowenfels";
declare license "MIT";
declare version "1.0";

import("stdfaust.lib");

//------------------------------`(dfl.)rpm`--------------------------------
// An environment with RPM (Recursive Phase Modulation) oscillators.
// Based on Norio Tomisawa's 1981 Yamaha patent for feedback FM synthesis.
// Uses a "hunting filter" (2-point moving average) in the feedback path
// to suppress Nyquist-rate limit cycle oscillations at high modulation indices.
//
// #### Usage
//
// ```
// rpm.saw(freq, beta) : _
// rpm.square(freq, beta) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
// * `beta`: modulation depth (0 to ~1.5)
//
// #### Variants
//
// * `saw(freq, beta)`: sawtooth-like waveform (sine morphs to saw as beta -> 1.5)
// * `square(freq, beta)`: odd-harmonic square-like waveform (squared feedback)
//
// #### References
//
// * <https://patents.google.com/patent/US4249447>
//----------------------------------------------------------------

rpm = environment {
    saw(freq, beta) = tick ~ (_,_) : _,!
    with {
        phase = os.phasor(1, freq) * 2 * ma.PI;
        tick(y1, y2) = out, y1
        with {
            y_avg = 0.5 * (y1 + y2);
            out = sin(phase - beta * y_avg);
        };
    };

    square(freq, beta) = tick ~ (_,_) : _,!
    with {
        phase = os.phasor(1, freq) * 2 * ma.PI;
        tick(y1, y2) = out, y1
        with {
            y_avg = 0.5 * (y1 + y2);
            out = sin(phase - beta * y_avg * y_avg);
        };
    };
};

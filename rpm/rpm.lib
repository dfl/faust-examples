// rpm.lib
// RPM (Recursive Phase Modulation) Oscillator Library
//
// Based on Norio Tomisawa's 1981 Yamaha patent for feedback FM synthesis:
// "Tone production method for an electronic musical instrument" (US4249447A)
// https://patents.google.com/patent/US4249447
//
// Uses a "hunting filter" (2-point moving average) in the feedback path
// to suppress Nyquist-rate limit cycle oscillations at high modulation indices.
//
// Usage:
//   dfl = library("rpm.lib");
//   process = dfl.saw(freq, beta);
//   process = dfl.sqr(freq, beta);

declare name "RPM Library";
declare author "David Lowenfels <dfl>";
declare version "1.0";
declare reference "https://patents.google.com/patent/US4249447";

import("stdfaust.lib");

//=============================================================================
// RPM Sawtooth
//=============================================================================
// Recursive phase modulation producing sawtooth-like waveform
// As beta increases from 0 toward ~1.5, morphs from sine to sawtooth
//
// Parameters:
//   freq - frequency in Hz
//   beta - modulation depth (0 to ~1.5)

saw(freq, beta) = tick ~ (_,_) : _,!
with {
    phasor = os.phasor(1, freq);
    phase = phasor * 2 * ma.PI;

    // tick takes (y1, y2) feedback, outputs (out, y1)
    // y1 = previous output, y2 = output from 2 samples ago
    tick(y1, y2) = out, y1
    with {
        y_avg = 0.5 * (y1 + y2);
        out = sin(phase + beta * y_avg);
    };
};

//=============================================================================
// RPM Square
//=============================================================================
// Recursive phase modulation producing square-like waveform
// Uses squared feedback for odd-harmonic-rich content (1, 3, 5, 7...)
//
// Parameters:
//   freq - frequency in Hz
//   beta - modulation depth (0 to ~1.5)

sqr(freq, beta) = tick ~ (_,_) : _,!
with {
    phasor = os.phasor(1, freq);
    phase = phasor * 2 * ma.PI;

    // tick takes (y1, y2) feedback, outputs (out, y1)
    // Squared feedback for odd-harmonic content
    tick(y1, y2) = out, y1
    with {
        sum_y = y1 + y2;
        y_avg = 0.5 * sum_y * sum_y;
        out = sin(phase - beta * y_avg);
    };
};

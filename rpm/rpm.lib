//############### rpm.lib ######################################################
// RPM (Recursive Phase Modulation) Oscillator Library
//
// Based on Norio Tomisawa's 1981 Yamaha patent for feedback FM synthesis:
// "Tone production method for an electronic musical instrument" (US4249447A)
//
// Uses a "hunting filter" (2-point moving average) in the feedback path
// to suppress Nyquist-rate limit cycle oscillations at high modulation indices.
//
// #### Usage
//
// ```
// dfl = library("rpm.lib");
// process = dfl.saw(freq, beta);
// ```
//
// #### Reference
//
// * <https://patents.google.com/patent/US4249447>
//##############################################################################

declare name "RPM Library";
declare author "David Lowenfels";
declare license "MIT";
declare version "1.0";

import("stdfaust.lib");

//============================= RPM Oscillators ================================
//==============================================================================

//------------------------`(dfl).saw`-------------------------------------------
// RPM sawtooth oscillator. Recursive phase modulation producing a
// sawtooth-like waveform. As beta increases from 0 toward ~1.5,
// morphs from sine to sawtooth.
//
// #### Usage
//
// ```
// dfl.saw(freq, beta) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
// * `beta`: modulation depth (0 to ~1.5)
//------------------------------------------------------------------------------
saw(freq, beta) = tick ~ (_,_) : _,!
with {
    phasor = os.phasor(1, freq);
    phase = phasor * 2 * ma.PI;

    // tick takes (y1, y2) feedback, outputs (out, y1)
    // y1 = previous output, y2 = output from 2 samples ago
    tick(y1, y2) = out, y1
    with {
        y_avg = 0.5 * (y1 + y2);
        out = sin(phase + beta * y_avg);
    };
};

//------------------------`(dfl).sqr`-------------------------------------------
// RPM square oscillator. Recursive phase modulation producing a
// square-like waveform with odd-harmonic-rich content (1, 3, 5, 7...).
// Uses squared feedback term.
//
// #### Usage
//
// ```
// dfl.sqr(freq, beta) : _
// ```
//
// Where:
//
// * `freq`: frequency in Hz
// * `beta`: modulation depth (0 to ~1.5)
//------------------------------------------------------------------------------
sqr(freq, beta) = tick ~ (_,_) : _,!
with {
    phasor = os.phasor(1, freq);
    phase = phasor * 2 * ma.PI;

    // tick takes (y1, y2) feedback, outputs (out, y1)
    // Squared feedback for odd-harmonic content
    tick(y1, y2) = out, y1
    with {
        sum_y = y1 + y2;
        y_avg = 0.5 * sum_y * sum_y;
        out = sin(phase - beta * y_avg);
    };
};
